"use strict";(self.webpackChunkdoeks_website=self.webpackChunkdoeks_website||[]).push([[841],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}},59028:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"guidance/benchmarking/test-scenarios/automatic-saturation-detection","title":"SCENARIO 3: Automatic Saturation Detection","description":"When to use this scenario:","source":"@site/docs/guidance/benchmarking/4-test-scenarios/3-automatic-saturation-detection.md","sourceDirName":"guidance/benchmarking/4-test-scenarios","slug":"/guidance/benchmarking/test-scenarios/automatic-saturation-detection","permalink":"/ai-on-eks/docs/guidance/benchmarking/test-scenarios/automatic-saturation-detection","draft":false,"unlisted":false,"editUrl":"https://github.com/awslabs/ai-on-eks/blob/main/website/docs/guidance/benchmarking/4-test-scenarios/3-automatic-saturation-detection.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_label":"Scenario 3 - Automatic Saturation Detection"},"sidebar":"guidance","previous":{"title":"Scenario 2 - Saturation Testing","permalink":"/ai-on-eks/docs/guidance/benchmarking/test-scenarios/saturation-testing"},"next":{"title":"Scenario 4 - Production Simulation","permalink":"/ai-on-eks/docs/guidance/benchmarking/test-scenarios/production-simulation"}}');var i=t(74848),a=t(28453);const r={sidebar_label:"Scenario 3 - Automatic Saturation Detection"},o="SCENARIO 3: Automatic Saturation Detection",c={},l=[{value:"When to use this scenario:",id:"when-to-use-this-scenario",level:2},{value:"Deployment",id:"deployment",level:2},{value:"Using Helm Chart (Recommended)",id:"using-helm-chart-recommended",level:3},{value:"Customizing Sweep Parameters",id:"customizing-sweep-parameters",level:3},{value:"Key Configuration:",id:"key-configuration",level:2},{value:"Understanding the results:",id:"understanding-the-results",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"scenario-3-automatic-saturation-detection",children:"SCENARIO 3: Automatic Saturation Detection"})}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-this-scenario",children:"When to use this scenario:"}),"\n",(0,i.jsx)(n.p,{children:"Use sweep mode for automated capacity discovery when you don't want to manually guess appropriate QPS test stages\u2014ideal for initial deployments, CI/CD pipelines, or quick capacity re-validation after infrastructure changes. The tool floods your system to empirically determine saturation, then automatically generates intelligent test stages clustered around that critical point. This eliminates human bias in test design and ensures consistent, reproducible methodology across different environments and teams, though you trade fine-grained control for scientific automation."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Choose Scenario 2"}),' when you need to validate specific load targets (e.g., "can we handle 20 QPS?") or want predictable test stages for production environments.']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Choose Scenario 3"})," when discovering unknown capacity limits or when consistent automated methodology matters more than testing specific QPS values."]}),"\n",(0,i.jsx)(n.h2,{id:"deployment",children:"Deployment"}),"\n",(0,i.jsx)(n.h3,{id:"using-helm-chart-recommended",children:"Using Helm Chart (Recommended)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Add the AI on EKS Helm repository\nhelm repo add ai-on-eks https://awslabs.github.io/ai-on-eks-charts/\nhelm repo update\n\n# Install sweep scenario\nhelm install sweep-test ai-on-eks/benchmark-charts \\\n  --set benchmark.scenario=sweep \\\n  --set benchmark.target.baseUrl=http://qwen3-vllm.default:8000 \\\n  --set benchmark.target.modelName=qwen3-8b \\\n  --set benchmark.target.tokenizerPath=Qwen/Qwen3-8B \\\n  --namespace benchmarking --create-namespace\n\n# Monitor progress - watch for automatic stage generation in logs\nkubectl logs -n benchmarking -l benchmark.scenario=sweep -f\n"})}),"\n",(0,i.jsx)(n.h3,{id:"customizing-sweep-parameters",children:"Customizing Sweep Parameters"}),"\n",(0,i.jsx)(n.p,{children:"Adjust saturation probe settings:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# custom-sweep.yaml\nbenchmark:\n  scenario: sweep\n  target:\n    baseUrl: http://your-model.your-namespace:8000\n  scenarios:\n    sweep:\n      load:\n        sweep:\n          numRequests: 3000        # More requests for larger systems\n          timeout: 90              # Longer probe time\n          numStages: 7             # More test stages\n          stageDuration: 240       # Longer stage duration\n          saturationPercentile: 99 # More conservative estimate\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"helm install sweep-test ai-on-eks/benchmark-charts -f custom-sweep.yaml -n benchmarking\n"})}),"\n",(0,i.jsx)(n.h2,{id:"key-configuration",children:"Key Configuration:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Variable synthetic data distributions"}),"\n",(0,i.jsx)(n.li,{children:"Sweep mode (automatic): floods system with configurable request count (default: 2000) over 60 seconds to discover saturation point"}),"\n",(0,i.jsx)(n.li,{children:"Auto-generated test stages using geometric clustering near saturation"}),"\n",(0,i.jsx)(n.li,{children:"Streaming enabled"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"understanding-the-results",children:"Understanding the results:"}),"\n",(0,i.jsxs)(n.p,{children:["The tool's preprocessing phase identifies saturation by flooding your system with 2000 requests over 60 seconds and measuring processing rate; the ",(0,i.jsx)(n.code,{children:"saturation_percentile: 95"})," means it uses the 95th percentile of observed rates for conservative estimates. Review the automatically generated stages in the logs (geometric clustering produces tighter spacing near saturation, like 4, 8, 14, 17, 18 QPS) and compare the detected saturation point against your manual testing expectations. Significant discrepancies reveal queueing bottlenecks or resource constraints you might have missed, and the geometric distribution provides rich data precisely where performance transitions from stable to degraded."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Configuring the Saturation Probe"}),": The ",(0,i.jsx)(n.code,{children:"numRequests"})," parameter in the sweep configuration controls how many requests are sent during the initial saturation discovery phase. The default value of 2000 is appropriate for most deployments, but you can adjust this based on your expected capacity."]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:(0,i.jsx)("strong",{children:"Alternative: Raw Kubernetes YAML"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: inference-perf-sweep\n  namespace: benchmarking\ndata:\n  config.yml: |\n    api:\n      type: completion\n      streaming: true\n\n    data:\n      type: synthetic\n      input_distribution:\n        mean: 512\n        std_dev: 128\n        min: 128\n        max: 2048\n      output_distribution:\n        mean: 256\n        std_dev: 64\n        min: 32\n        max: 512\n\n    load:\n      type: constant\n      stages: []  # Auto-generated by sweep\n      sweep:\n        type: geometric\n        num_requests: 2000\n        timeout: 60\n        num_stages: 5\n        stage_duration: 180\n        saturation_percentile: 95\n      num_workers: 8\n\n    server:\n      type: vllm\n      model_name: qwen3-8b\n      base_url: http://qwen3-vllm.default:8000\n      ignore_eos: true\n\n    tokenizer:\n      pretrained_model_name_or_path: Qwen/Qwen3-8B\n\n    storage:\n      simple_storage_service:\n        bucket_name: "inference-perf-results"\n        path: "sweep-test/results"\n---\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: inference-perf-sweep\n  namespace: benchmarking\nspec:\n  backoffLimit: 2\n  ttlSecondsAfterFinished: 3600\n  template:\n    spec:\n      restartPolicy: Never\n      serviceAccountName: inference-perf-sa\n\n      affinity:\n        podAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n          - labelSelector:\n              matchLabels:\n                app.kubernetes.io/component: qwen3-vllm\n            topologyKey: topology.kubernetes.io/zone\n\n      containers:\n      - name: inference-perf\n        image: quay.io/inference-perf/inference-perf:v0.2.0\n        command: ["/bin/sh", "-c"]\n        args:\n        - |\n          inference-perf --config_file /workspace/config.yml\n        volumeMounts:\n        - name: config\n          mountPath: /workspace/config.yml\n          subPath: config.yml\n        resources:\n          requests:\n            cpu: "2"\n            memory: "4Gi"\n          limits:\n            cpu: "4"\n            memory: "8Gi"\n\n      volumes:\n      - name: config\n        configMap:\n          name: inference-perf-sweep\n'})})]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);